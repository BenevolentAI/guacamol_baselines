import logging
import os
from time import time
from typing import List, Optional, Set, Tuple

import numpy as np
import pandas as pd
from rdkit import Chem

from frag_gt.src.io import load_smiles_from_file, valid_mols_from_smiles
from frag_gt.src.mapelites import map_elites_factory
from frag_gt.src.population import MolecularPopulationGenerator, Molecule
from frag_gt.src.scorers import SmilesScorer

logger = logging.getLogger(__name__)


_DEFAULT_FRAGSTORE_DIR = os.path.join(os.path.dirname(os.path.realpath(__file__)), "../data/fragment_libraries")
_DEFAULT_POPULATION_SMILES_DIR = os.path.join(os.path.dirname(os.path.realpath(__file__)), "../data/smiles_files")
DEFAULT_FRAGSTORE_PATH = os.path.join(_DEFAULT_FRAGSTORE_DIR, "chembl_29_chemreps_std_fragstore_brics_filter2.pkl")
DEFAULT_STARTING_POPULATION_SMILES_PATH = os.path.join(_DEFAULT_POPULATION_SMILES_DIR, "chembl_29_chemreps_std.smiles")


class FragGTGenerator:
    def __init__(self,
                 smi_file: str = DEFAULT_STARTING_POPULATION_SMILES_PATH,
                 fragmentation_scheme: str = "brics",
                 fragstore_path: str = DEFAULT_FRAGSTORE_PATH,
                 allow_unspecified_stereo: bool = True,
                 scorer: str = "counts",
                 operators: Optional[List[Tuple[str, float]]] = None,
                 population_size: int = 100,
                 n_mutations: int = 50,
                 generations: int = 500,
                 map_elites: Optional[str] = None,
                 random_start: bool = False,
                 patience: int = 5,
                 n_jobs: int = -1,
                 intermediate_results_dir: Optional[str] = None):
        """

        Args:
            smi_file: path to a smiles file containing molecules to be scored and used as an initial population
                       starting population can be overridden by providing `starting_population` to `optimize`
            fragmentation_scheme: method to use for fragmenting molecules, currently only "brics" is available
                       must match the fragmentation method used to generate fragstore
            fragstore_path: path to fragstore pkl containing fragments derived from a corpus used to mutate molecules
                       fragstores are created by `generate_fragstore.py` and are specific to a fragmentation scheme
            allow_unspecified_stereo: if false, unspecified stereocenters will be enumerated to specific stereoisomers
            scorer: scoring method with which to rank fragment replacements (random|counts|ecfp4|afps)
            operators: List of tuples of mutation and crossover operators and probability of applying [(op, prob)]
                       ops: substitute_node_mutation|add_node_mutation|delete_node_mutation|single_point_crossover
                       probabilities must sum to one
            population_size: size of the pool of molecules carried between subsequent generations
            n_mutations: number of mutations per generation (num new molecules generated by applying operators)
            generations: number of generations to optimize for
            map_elites: if provided use mapelites algorithm to encourage diversity in the population.
                       valid args: species|mwlogp. Top scoring molecules from distinct subdivisions of solution space
                       are kept in the population.
            random_start: if True, take a random subset of smiles in `smi_file` as initial population
            patience: number of generations to continue if no progress is made on the optimization objective
            n_jobs: number of threads
            intermediate_results_dir: directory to save molceules and scores for intermediate generations
                       (must provide `job_name` to `self.optimize`)
        """
        self.smi_file = smi_file
        self.fragmentation_scheme = fragmentation_scheme
        self.fragstore_path = fragstore_path
        self.allow_unspecified_stereo = allow_unspecified_stereo
        self.scorer = scorer
        self.operators = operators
        self.population_size = population_size
        self.n_mutations = n_mutations
        self.generations = generations
        self.random_start = random_start
        self.patience = patience
        self.n_jobs = n_jobs
        self.intermediate_results_dir = intermediate_results_dir

        # map-elites (frag-gti)
        self.map_elites = None if map_elites is None else map_elites_factory(map_elites, fragmentation_scheme)

        logger.info(self.__dict__)

    @staticmethod
    def top_k(mols: List[Chem.rdchem.Mol], scoring_function: SmilesScorer, k: int):
        scores = scoring_function.score_list([Chem.MolToSmiles(m) for m in mols])
        scored_mols = list(zip(scores, mols))
        scored_mols = sorted(scored_mols, key=lambda x: x[0], reverse=True)[:k]
        return [mol for score, mol in scored_mols]

    def get_initial_population(self, scoring_function: SmilesScorer) -> List[Chem.rdchem.Mol]:
        init_size = self.population_size + self.n_mutations

        raw_smiles = load_smiles_from_file(self.smi_file)
        if self.random_start:
            logger.info(f"taking a random subset of smiles as initial population (init_size: {init_size})")
            raw_smiles = np.random.choice(raw_smiles, init_size)

        initial_population = valid_mols_from_smiles(raw_smiles, self.n_jobs)

        if len(initial_population) > init_size:
            initial_population = self.top_k(initial_population, scoring_function, init_size)

        return initial_population

    @staticmethod
    def deduplicate(population: List[Molecule]) -> List[Molecule]:
        unique_smiles = set()  # type: Set[str]
        unique_population = []
        for m in population:
            score, mol = m
            smiles = Chem.MolToSmiles(mol)
            if smiles not in unique_smiles:
                unique_population.append(m)
                unique_smiles.add(smiles)
        return unique_population

    def write_generation_results(self,
                                 population: List[Molecule],
                                 generation: int,
                                 job_name: str,
                                 all_generations_results_dir: str):
        df = pd.DataFrame()
        df["SMILES"] = [Chem.MolToSmiles(p.mol) for p in population]
        df["scores"] = [p.score for p in population]
        df["gen"] = generation + 1
        df["fragmentation"] = self.fragmentation_scheme
        df["fragstore"] = self.fragstore_path

        safe_job_name = job_name.replace(" ", "_").lower()
        df.to_csv(f"{all_generations_results_dir}/{str(safe_job_name)}_{generation + 1}.csv")

    def optimize(self,
                 scoring_function: SmilesScorer,
                 number_molecules: int,
                 starting_population: Optional[List[str]] = None,
                 fixed_substructure_smarts: Optional[str] = None,
                 job_name: Optional[str] = None,
                 ) -> List[str]:
        """
        Generate optimal molecules!

        Args:
            scoring_function: scorer instance used to assess molecular fitness
            number_molecules: number of optimal molecules to return
            starting_population: if given, use this list of smiles as starting population instead of generator default
            fixed_substructure_smarts: if given, all output molecules must contain this SMARTS.
                molecules are filtered before scoring which can be more efficient than providing a SMARTS scorer class.
            job_name: if provided, and `intermediate_results_dir` is not None.
                this argument is used as the filename for writing molecules and scores seen in intermediate generations.

        Returns:
            list of optimal smiles
        """

        if number_molecules > self.population_size:
            self.population_size = number_molecules
            logger.info(f"Benchmark requested more molecules than expected: new population is {number_molecules}")

        # prepare initial population
        logger.info("preparing initial population...")
        if starting_population is None:
            # use the smiles file provided in the init to generate a starting population
            logger.info(f"loading initial population from smiles file: {self.smi_file}")
            initial_population = self.get_initial_population(scoring_function)
        else:
            # user-provided smiles are used as a starting population, parse and remove invalids
            logger.info(f"using user provided initial population for generation: {starting_population}")
            initial_population = valid_mols_from_smiles(starting_population, self.n_jobs)

        # score initial population of mol objects
        logger.info("scoring initial population...")
        population_scores = scoring_function.score_list([Chem.MolToSmiles(x) for x in initial_population])

        # compile initial population
        population = [Molecule(*m) for m in zip(population_scores, initial_population)]
        population = self.deduplicate(population)

        # map-elites
        if self.map_elites is not None:
            population, _ = self.map_elites.place_in_map(population)

        # survival of the fittest
        population = sorted(population, key=lambda x: x.score, reverse=True)[:self.population_size]

        # write molecules from initial generation
        if (self.intermediate_results_dir is not None) and (job_name is not None):
            self.write_generation_results(population, -1, job_name, self.intermediate_results_dir)

        # Keep track of scores to enable early stopping
        population_scores = [p.score for p in population]

        # init mol generator class with method for fragmentation
        mol_generator = MolecularPopulationGenerator(fragstore_path=self.fragstore_path,
                                                     fragmentation_scheme=self.fragmentation_scheme,
                                                     n_molecules=self.n_mutations,
                                                     operators=self.operators,
                                                     allow_unspecified_stereo=self.allow_unspecified_stereo,
                                                     selection_method="tournament",
                                                     scorer=self.scorer,
                                                     fixed_substructure_smarts=fixed_substructure_smarts)

        # evolution: go go go!!
        logger.info("starting evolution...")

        # log something about the initial generation
        logger.info(f"i | "
                    f"max: {np.max(population_scores):.3f} | "
                    f"avg: {np.mean(population_scores):.3f} | "
                    f"min: {np.min(population_scores):.3f} | "
                    f"std: {np.std(population_scores):.3f} | "
                    f"pop: {len(population_scores)}")

        patience = 0
        t0 = time()
        for generation in range(self.generations):

            # keep track of old scores for early stopping (patience)
            old_scores = population_scores

            # generate new pool by applying mutation and crossover operators to existing pool
            new_population = mol_generator.generate(population)

            # don't score molecules that have been scored before
            existing_population_smiles = {Chem.MolToSmiles(x.mol) for x in population}
            new_population_tuples = {(m, Chem.MolToSmiles(m)) for m in new_population}
            new_mol_tuples = [(m, s) for m, s in new_population_tuples if s not in existing_population_smiles]
            if not len(new_mol_tuples):
                patience += 1
                logger.info(f"Failed to progress by generating new molecules: {patience}")
                if patience >= self.patience:
                    logger.info("No more patience, bailing...")
                    break
                else:
                    continue
            new_molecules, new_smiles = zip(*new_mol_tuples)
            logger.debug(f"{len(new_population)-len(new_molecules)} smiles already existed in the population")

            # score
            new_scores = scoring_function.score_list(new_smiles)

            # compile new population
            assert len(new_scores) == len(new_molecules)
            new_population = [Molecule(*m) for m in zip(new_scores, new_molecules)]

            # join and deduplicate
            population += new_population
            population = self.deduplicate(population)

            # map-elites
            if self.map_elites is not None:
                population, _ = self.map_elites.place_in_map(population)

            # survival of the fittest
            population = sorted(population, key=lambda x: x.score, reverse=True)[:self.population_size]

            # early stopping
            population_scores = [p.score for p in population]
            if population_scores == old_scores:
                patience += 1
                logger.info(f"Failed to progress on fitness landscape: {patience}")
                if patience >= self.patience:
                    logger.info("No more patience, bailing...")
                    break
            else:
                patience = 0

            # calculate stats
            gen_time = time() - t0
            mol_sec = (self.population_size + self.n_mutations) / gen_time
            t0 = time()

            # log something about this generation
            logger.info(f"{generation} | "
                        f"max: {np.max(population_scores):.3f} | "
                        f"avg: {np.mean(population_scores):.3f} | "
                        f"min: {np.min(population_scores):.3f} | "
                        f"std: {np.std(population_scores):.3f} | "
                        f"pop: {len(population_scores)} | "
                        f"{gen_time:.2f} sec/gen | "
                        f"{mol_sec:.2f} mol/sec")

            # write molecules from current generation
            if (self.intermediate_results_dir is not None) and (job_name is not None):
                self.write_generation_results(population, generation, job_name, self.intermediate_results_dir)

        # finally
        return [Chem.MolToSmiles(molecule.mol) for molecule in population[:number_molecules]]
